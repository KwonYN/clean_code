# 13. 동시성

맞다. 스레드 이야기다.

동시성과 깔끔한 코드는 양립하기 어려움. 평소에는 멀쩡해 보이기 때문에 문제를 발견하기도, 문제가 발생했을 때 대처하기도 어려움. 그럼에도 불구하고 스레드로 작업이 필요한 경우가 있음. 그럼 어떻게 해야 할까?



## 동시성이 필요한 이유: 여러 스레드를 동시에 돌리는 이유

동시성은 **결합을 없애**는 전략(Decoupling).

1. 무엇(What)과 언제(When)를 **분리**하면 애플리케이션 **구조와 효율이 나아짐**. 하지만 완벽한 것은 아님.

   - 작은 협력 프로그램 여럿으로 분리.
   - Ex. **Servlet**(서브릿) 모델
     - Servlet: 클라이언트 요청을 처리하고, 그 결과를 반환하는 자바 웹 프로그래밍 기술.
     - 서브릿 or EJB 컨테이너라는 것이 동시성을 부분적으로 관리함.
     - 모든 웹 요청을 관리할 필요 없음.
     - **서블릿 스레드는 다른 서블릿 스레드와 무관하게 독립적으로 동작함.**

2. **병렬 처리**로 **응답 시간과 처리량(Throughput) 개선**

   - Ex.
     - (한 스레드만으로 작업 가정) 한 작업이 끝나야 다음 작업으로 넘어가야 하는 상황에서 해당 작업이 늘어나게 되면 대기 시간이 늘어남.
     - 한 번에 한 사용자를 처리하는 시스템은 사용자 수가 늘어날수록 응답 속도가 늘어남.
   - 이런 상황에서 **여러 스레드가 동시에 작업을 처리한다면, 응답 시간과 처리량이 향상**됨.

   

   #### 동시성에 대한 오해/미신과 타당한 생각

   이렇게 **동시성이 필요**한 상황이 존재. 하지만 동시성을 제대로 **구현하기는 어려움**.

   - 일반적인 미신과 오해

     - 동시성은 *항상* 성능을 높여줌.

       - **때로** 성능을 높여줄 수는 있지만, 항상 성능을 향상시키는 것은 아님.

       - 대기 시간이 아주 길어 여러 스레드가 프로세스를 공유할 수 있는 경우,

         여러 프로세서가 동시에 처리할 독립적인 계산이 충분히 많은 경우에만 성능 향상됨.

     - 동시성을 구현해도 *설계는 변하지 않음*.

       - 단일 스레드와 다중 스레드 시스템은 **설계가 판이하게 다름**.

     - 웹/EJB 컨테이너를 사용하면 동시성을 *이해할 필요 없이 사용*하면 됨.

       - 동시에 어떻게 동작하는지, 어떤 문제가 있을 수 있는지 **알아야 함**.

   - 타당한 생각

     - 동시성은 **부하** 유발할 수 있음.
     - **복잡**합.
     - 동시성으로 발생하는 **버그는 재현하기 어려움**.
     - 동시성 구현을 위해 **근본적인 설계 전략 재고**해야 함.



## 동시성을 구현하기 어려운 이유

```java
public class example {
    private int count = 0;
    
    public int increase() {
        return ++count;
    }
}
```

- 두 개의 스레드에서 increase() 메서드를 한 번 호출하면, 세 가지 상황 발생.

  - 0 - 1 // 1 - 0 // 0 - 0

- 두 스레드가 같은 변수를 **동시에 참조**하기에 세 번째 상황 발생;;

  

## 동시성의 어려움에 대처하는 방법

1. ##### 단일 책임 원칙 (SRP; Single Responsibility Principle)

   - 동시성 코드를 다른 일반적인 코드와 **분리**하여 메서드/클래스/컴포넌트는 각각 **하나의 책임만 갖도록**.

2. ##### 자료 범위 제한

   - 따름 정리(Corollary) : 이미 증명된 다른 정리로부터 쉽게 밝혀낼 수 있는 부가적인 명제. 추론.

   - 서로 다른 스레드가 서로 **간섭**하면 예상치 못한 결과를 내놓기 때문에

     **임계 영역**(Critical Section; 동시 사용을 막아야만 올바로 동작하는 보호 받는 코드 영역)을

     `synchronized` 키워드로 보호하여 **캡슐화**는 것을 권장함.

     - `synchronized` 키워드
       - 멀티 쓰레드 환경에서 순차적으로 코드가 실행된다는 것을 보장할 수 없음.
       - `synchronized block`에는 하나의 스레드만 진입할 수 있음.
       - 하나의 스레드가 값을 변경한 이후에 다음 스레드가 값을 변경할 수 있게 함.

   - 즉, **공유되는 자료를 최대한 줄이는 방법**

3. ##### 자료 사본 사용

   - 객체를 복사해 읽기 전용으로 사용. 이를 통해 **자료의 공유(여러 군데에서 동시에 같이 사용)를 막음**.
   - 복사로 인한 부하? → 내부 잠금을 없애 절약한 수행시간을 상쇄할 가능성이 큼.

4. ##### 스레드 독립적으로 구현

   - HttpServlet 클래스 : 각 서블릿은 마치 자기 자신이 독자적인 시스템에서 동작하는 양 **클라이언트 요청 하나만을 독립적으로 처리**.
     - 이를 통해 **동기화를 통한 문제 발생 가능성 없앰**.



#### 	깨끗한 코드를 작성하는 방법

1. 라이브러리 이해

   - Ex. `java.util.concurrent`  패키지 : 스레드 환경에 안전한 컬렉션

     ```java
     import java.util.concurrent;
     
     public class MemoryMemberRepository implements MemberRepository {
         private static Map<Long, Member> store = new ConcurrentHashMap<>();
         
         @Override
         public void save(Member member) {
         	store.put(member.getId(), member);
         }
         
         @Override
         public Member findById(Long memberId) {
         	return store.get(memberId);
         }
     }
     ```

     - 동시에 put으로 수정하는 경우
       - `HashMap`은 전체에 Lock을 거는 반면, `ConcurrentHashMap`은 일부에만 Lock을 걸고 접근할 수 있도록 설계되었음. 

   - **언어가 제공하는 라이브러리를 이해하고, 동시성을 안전하게 지원하는 클래스 사용**.

2. 실행 모델 이해

   - 생산자 - 소비자 모델

     - 생산자 스레드: 대기열에 정보를 채운 후, "대기열에 정보가 있다"는 소비자 스레드에 시그널 보냄.
     - 소비자 스레드: 대기열에 정보 읽고, "대기열에 빈 공간이 있다"는 시그널 보냄.
     - 이러한 서로의 신호를 받고 작업을 하는데... 그 전에는 **대기**를 타고 있음. 즉, **동시에 시그널을 보내는 상황에서 꼬여서 계속 대기만 하고 있을 가능성**.

   - 읽기 - 쓰기

     - Write 스레드 동작 중 Reader 스레드가 버퍼 갱신하지 않도록, vice versa

       **한 스레드가 너무 오랫동안 점유하지 않도록 균형 필요**. (처리율 떨어지지 않도록.)

   - 식사하는 철학자들

     - https://simsimjae.tistory.com/72

     - **Deadlock**

       - 무한 교착 상태. 영원히 오지 않는 이벤트를 기다리는 것.
       - Ex. 왼쪽 포크 hold → 오른쪽 포크 hold → 식사 → 왼쪽 포크 down → 오른쪽 포크 down
         - 모두 동시에 왼쪽 포크를 hold하게 된다면, 오른쪽 포크를 들려고 하지만 남은 포크가 없어 아무 일도 할 수가 없게 됨...!

     - **Starvation** (기아)

       - 프로세스가 계속해서 필요한 자원을 가져오지 못하는 상황.
       - 하나의 프로세스가 계속 점유하고 있는 경우, 우선순위에서 계속 밀려있는 경우 등.
       - Ex. 왼쪽 포크 hold → 오른쪽 포크 check → 없으면 포크 down → ...
         - 오른쪽 포크가 없을 때, 계속해서 왼쪽 포크 들었다 놨다 하면서 먹지 못함.. 기아 현상.

     - 해결? ▶ **Semaphore**

       - 이진세마포어(**mutex**)로 포크를 드는 행위(임계구역)를 하는 곳을 감쌈.

         이는 한 명이 포크를 드는 행위를 시작하면, Lock이 걸리면서 다른 사람은 대기를 해야 함.

         - 이렇게 되면 어찌되었든 한 명씩 돌아가면서 계속 먹을 수 있음!!

       - 그런데 최대 두 명이 동시에 먹을 수 있음!!

3. 동기화하는 메서드 사이에 존재하는 의존성 이해

   - 공유 객체 하나에 여러 `synchronized` 메서드가 있다면, **불필요한 의존성 생길 수 있으니 되도록이면 하나로 줄여라**.
   - 만약 여러 메서드를 사용해야 하는 상황이라면, 첫 ~ 끝 메서드 호출 때까지 잠금이 유지되도록.

4. 동기화 부분 작게 만들기

   - (여러 스레드가 동시에 사용해야 하는 경우, 이를 막아야 안전하게 동작할 수 있는데) 이런 **임계 영역을 최대한으로 줄여야 함**.
   - 그렇다고 임계영역 하나를 잡고 그 안에 여러 코드 다 때려박으면, 스레드 간의 경쟁이 늘어나고 성능이 떨어짐.

5. 올바른 종료 코드 구현

   - 부모 스레드가 자식 스레드 여러 개를 만들고, 이 자식 스레드가 끝날 때까지 기다리는 경우.
     - 자식 스레드 중 하나가 데드락 걸리면, 영원히 기다림.
   - 부모 스레드가 자식 스레드에게 종료 시그널을 보냈지만, 자식들 간 생산자-소비자 관계라서 서로의 시그널을 기다리는 경우.
     - 두 자식들은 서로의 시그널을 기다리느라 부모 스레드의 시그널을 받지 못하고 영원히 기다림
   - **종료 코드를 잘 구현하여 영원히 기다리는 상황 막자**.



## 동시성 테스트 방법과 문제점

1. ##### 말이 안되는 실패는 잠정적인 스레드 문제로 취급

   - '음..? 이게 왜..? 이거 잘 모르겠는데..?' 하는 문제를 일회성 문제로 생각하고 **무시하지 말자**.

2. ##### 다중 스레드를 고려하지 않은 순차 코드부터 제대로 돌게 만들기

   - POJO(Plain Old Java Object; 평범한 자바 객체)는 스레드를 모름.
   - 일단 스레드 환경 밖에서 잘 돌아가는 테스트 코드를 구현한 후, 스레드 환경에서 테스트.

3. ##### 다양한 환경에 쉽게 끼워넣을 수 있게 스레드 코드 구현

   - 다양한 설정으로 테스트를 해보면서 다중 스레드 적용.

4. ##### 상황에 맞게 조율할 수 있도록 작성

   - 다양한 설정으로 성능 측정.

5. ##### 프로세서 수보다 많은 스레드 돌려보기

   - 부하를 일으켜 임계영역을 빼먹은 코드나 데드락을 일으키는 코드 찾기 쉬워짐.

6. ##### 다른 플렛폼에서 돌려보기

   - 플랫폼마다 스레드 처리 정책이 다름.

7. ##### 보조 코드 넣어 돌려 보고, 의도적으로 실패 상황을 만들기

   - 알고리즘 디버깅 하듯이.



## 결론

1. 단일 책임 원칙
   - 스레드 관련 코드와 아닌 코드 분리.
   - 스레드 코드를 최대한 집약시키되 작게 코드를 짜야 함.
2. 동시성 오류를 일으키는 잠정적인 원인 이해
   - 공유 자료 조작이 주된 원인
3. 사용하는 동시성 관련 라이브러리와 기본 알고리즘 이해
4. 보호해야 할 코드 영역을 찾아내고, 특정 코드를 잠그는 방법 이해
   - 공유하는 객체의 수와 범위를 최대한 줄여야 함.
5. 발생하는 문제에 대해서는 무시하지 말고, 테스트를 통해 이해

